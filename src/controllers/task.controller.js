import { Task } from "../models/task.model.js";

// Helper function to check if a date matches a recurring pattern
const matchesRecurringPattern = (date, parentDate, pattern) => {
  const targetDate = new Date(date);
  targetDate.setHours(0, 0, 0, 0);
  const parent = new Date(parentDate);
  parent.setHours(0, 0, 0, 0);

  if (targetDate <= parent) return false; // Don't create instances before parent date

  const daysDiff = Math.floor((targetDate - parent) / (1000 * 60 * 60 * 24));
  const dayOfWeek = targetDate.getDay(); // 0 = Sunday, 6 = Saturday

  if (pattern.frequency === "daily") {
    return daysDiff > 0 && daysDiff % pattern.interval === 0;
  } else if (pattern.frequency === "weekdays") {
    // Monday to Friday (1-5)
    if (dayOfWeek < 1 || dayOfWeek > 5) return false;
    // Count weekdays from parent to target
    let weekdayCount = 0;
    const checkDate = new Date(parent);
    checkDate.setDate(checkDate.getDate() + 1); // Start from next day
    while (checkDate <= targetDate) {
      const checkDay = checkDate.getDay();
      if (checkDay >= 1 && checkDay <= 5) {
        weekdayCount++;
      }
      checkDate.setDate(checkDate.getDate() + 1);
    }
    // Check if it's a multiple of interval weeks (5 weekdays per week)
    return weekdayCount > 0 && weekdayCount % (pattern.interval * 5) === 0;
  } else if (pattern.frequency === "weekly") {
    if (!pattern.daysOfWeek || !pattern.daysOfWeek.includes(dayOfWeek)) return false;
    const weeksDiff = Math.floor(daysDiff / 7);
    return weeksDiff > 0 && weeksDiff % pattern.interval === 0;
  } else if (pattern.frequency === "monthly") {
    if (targetDate.getDate() !== parent.getDate()) return false;
    const monthsDiff = (targetDate.getFullYear() - parent.getFullYear()) * 12 + 
                       (targetDate.getMonth() - parent.getMonth());
    return monthsDiff > 0 && monthsDiff % pattern.interval === 0;
  }

  return false;
};

// Helper function to generate recurring task instances
const generateRecurringTaskInstances = async (parentTask, maxDaysAhead = 30) => {
  if (!parentTask.isRecurring || !parentTask.repeatPattern) {
    return [];
  }

  const pattern = parentTask.repeatPattern;
  const startDate = new Date(parentTask.date);
  startDate.setHours(0, 0, 0, 0);
  
  const endDate = pattern.endDate 
    ? new Date(pattern.endDate)
    : new Date(startDate.getTime() + maxDaysAhead * 24 * 60 * 60 * 1000);
  endDate.setHours(23, 59, 59, 999);

  const instances = [];
  const currentDate = new Date(startDate);
  currentDate.setDate(currentDate.getDate() + 1); // Start from next day

  while (currentDate <= endDate) {
    if (matchesRecurringPattern(currentDate, startDate, pattern)) {
      // Check if instance already exists
      const dayStart = new Date(currentDate);
      dayStart.setHours(0, 0, 0, 0);
      const dayEnd = new Date(currentDate);
      dayEnd.setHours(23, 59, 59, 999);

      const existingTask = await Task.findOne({
        userId: parentTask.userId,
        parentTaskId: parentTask._id,
        date: { $gte: dayStart, $lte: dayEnd },
      });

      if (!existingTask) {
        const instanceData = {
          userId: parentTask.userId,
          title: parentTask.title,
          description: parentTask.description,
          date: new Date(dayStart),
          type: parentTask.type,
          quantity: parentTask.quantity,
          value: parentTask.value,
          goalId: parentTask.goalId,
          isAutoGenerated: false,
          completed: false,
          isRecurring: false, // Instances are not recurring themselves
          parentTaskId: parentTask._id,
          priority: parentTask.priority,
          tags: parentTask.tags,
          reminder: parentTask.reminder,
          duration: parentTask.duration,
        };

        instances.push(instanceData);
      }
    }

    // Move to next day
    currentDate.setDate(currentDate.getDate() + 1);
  }

  // Create all instances
  if (instances.length > 0) {
    await Task.insertMany(instances);
  }

  return instances;
};

// Get all tasks for a user
export const getTasks = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const { date, completed, type } = req.query;

    const query = { userId };

    if (date) {
      const taskDate = new Date(date);
      const startOfDay = new Date(taskDate.setHours(0, 0, 0, 0));
      const endOfDay = new Date(taskDate.setHours(23, 59, 59, 999));
      query.date = { $gte: startOfDay, $lte: endOfDay };
    }

    if (completed !== undefined) {
      query.completed = completed === "true";
    }

    if (type) {
      query.type = type;
    }

    const tasks = await Task.find(query).sort({ date: -1, createdAt: -1 });

    res.status(200).json({
      success: true,
      count: tasks.length,
      tasks,
    });
  } catch (error) {
    next(error);
  }
};

// Get tasks for a specific date
export const getTasksByDate = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const date = req.params.date;

    const taskDate = new Date(date);
    const startOfDay = new Date(taskDate);
    startOfDay.setHours(0, 0, 0, 0);
    const endOfDay = new Date(taskDate);
    endOfDay.setHours(23, 59, 59, 999);

    const tasks = await Task.find({
      userId,
      date: { $gte: startOfDay, $lte: endOfDay },
    }).sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      count: tasks.length,
      tasks,
    });
  } catch (error) {
    next(error);
  }
};

// Get single task
export const getTask = async (req, res, next) => {
  try {
    const task = await Task.findOne({
      _id: req.params.id,
      userId: req.user.id,
    });

    if (!task) {
      return res.status(404).json({
        success: false,
        message: "Task not found",
      });
    }

    res.status(200).json({
      success: true,
      task,
    });
  } catch (error) {
    next(error);
  }
};

// Create task
export const createTask = async (req, res, next) => {
  try {
    const {
      title,
      description,
      date,
      type,
      quantity,
      value,
      goalId,
      isRecurring,
      repeatPattern,
      priority,
      tags,
      reminder,
      duration,
    } = req.body;

    // Validate type
    if (!["binary", "count", "value"].includes(type)) {
      return res.status(400).json({
        success: false,
        message: "Invalid task type. Must be binary, count, or value",
      });
    }

    // Validate type-specific fields
    if (type === "count" && (!quantity || quantity <= 0)) {
      return res.status(400).json({
        success: false,
        message: "Quantity is required and must be greater than 0 for count-based tasks",
      });
    }

    if (type === "value" && (value === null || value === undefined)) {
      return res.status(400).json({
        success: false,
        message: "Value is required for value-based tasks (0 is allowed)",
      });
    }

    const taskData = {
      userId: req.user.id,
      title: title.trim(),
      description: description || "",
      date: new Date(date),
      type,
      quantity: type === "count" ? quantity : null,
      value: type === "value" ? value : null,
      completed: false,
      isRecurring: isRecurring || false,
      priority: priority || "medium",
      tags: tags && Array.isArray(tags) ? tags : [],
      duration: duration || null,
    };

    // Add repeat pattern if recurring
    if (isRecurring && repeatPattern) {
      taskData.repeatPattern = {
        frequency: repeatPattern.frequency,
        interval: repeatPattern.interval || 1,
        endDate: repeatPattern.endDate ? new Date(repeatPattern.endDate) : null,
        daysOfWeek: repeatPattern.daysOfWeek && Array.isArray(repeatPattern.daysOfWeek) ? repeatPattern.daysOfWeek : null,
      };
    }

    // Add reminder if enabled
    if (reminder && reminder.enabled) {
      taskData.reminder = {
        enabled: true,
        reminderTime: reminder.reminderTime ? new Date(reminder.reminderTime) : null,
      };
    } else {
      taskData.reminder = {
        enabled: false,
        reminderTime: null,
      };
    }

    const task = await Task.create(taskData);

    // Generate recurring task instances if this is a recurring task
    let generatedInstances = [];
    if (task.isRecurring && task.repeatPattern) {
      generatedInstances = await generateRecurringTaskInstances(task, 30); // Generate for next 30 days
    }

    res.status(201).json({
      success: true,
      message: `Task created successfully${task.isRecurring && generatedInstances.length > 0 ? ` with ${generatedInstances.length} recurring instances` : ""}`,
      task,
      generatedInstances: generatedInstances.length,
    });
  } catch (error) {
    next(error);
  }
};

// Update task
export const updateTask = async (req, res, next) => {
  try {
    const task = await Task.findOne({
      _id: req.params.id,
      userId: req.user.id,
    });

    if (!task) {
      return res.status(404).json({
        success: false,
        message: "Task not found",
      });
    }

    const {
      title,
      description,
      date,
      type,
      quantity,
      value,
      isRecurring,
      repeatPattern,
      priority,
      tags,
      reminder,
      duration,
    } = req.body;

    // Update fields
    if (title) task.title = title.trim();
    if (description !== undefined) task.description = description;
    if (date) task.date = new Date(date);
    if (type) {
      // Validate type
      if (!["binary", "count", "value"].includes(type)) {
        return res.status(400).json({
          success: false,
          message: "Invalid task type. Must be binary, count, or value",
        });
      }
      task.type = type;
    }

    if (type === "count" || task.type === "count") {
      if (quantity !== undefined) {
        if (quantity <= 0) {
          return res.status(400).json({
            success: false,
            message: "Quantity must be greater than 0 for count-based tasks",
          });
        }
        task.quantity = quantity;
        task.value = null;
      }
    }

    if (type === "value" || task.type === "value") {
      if (value !== undefined) {
        task.value = value;
        task.quantity = null;
      }
    }

    // Update recurring options
    if (isRecurring !== undefined) {
      task.isRecurring = isRecurring;
      if (isRecurring && repeatPattern) {
        task.repeatPattern = {
          frequency: repeatPattern.frequency,
          interval: repeatPattern.interval || 1,
          endDate: repeatPattern.endDate ? new Date(repeatPattern.endDate) : null,
          daysOfWeek: repeatPattern.daysOfWeek && Array.isArray(repeatPattern.daysOfWeek) ? repeatPattern.daysOfWeek : null,
        };
      } else if (!isRecurring) {
        task.repeatPattern = null;
        task.parentTaskId = null;
      }
    }

    // Update other options
    if (priority !== undefined) task.priority = priority;
    if (tags !== undefined) task.tags = Array.isArray(tags) ? tags : [];
    if (duration !== undefined) task.duration = duration || null;

    // Update reminder
    if (reminder !== undefined) {
      if (reminder.enabled) {
        task.reminder = {
          enabled: true,
          reminderTime: reminder.reminderTime ? new Date(reminder.reminderTime) : null,
        };
      } else {
        task.reminder = {
          enabled: false,
          reminderTime: null,
        };
      }
    }

    await task.save();

    res.status(200).json({
      success: true,
      message: "Task updated successfully",
      task,
    });
  } catch (error) {
    next(error);
  }
};

// Delete task
export const deleteTask = async (req, res, next) => {
  try {
    const task = await Task.findOne({
      _id: req.params.id,
      userId: req.user.id,
    });

    if (!task) {
      return res.status(404).json({
        success: false,
        message: "Task not found",
      });
    }

    // Delete the task
    await Task.findByIdAndDelete(task._id);

    res.status(200).json({
      success: true,
      message: "Task deleted successfully",
    });
  } catch (error) {
    next(error);
  }
};

// Toggle task completion
export const toggleTaskCompletion = async (req, res, next) => {
  try {
    const task = await Task.findOne({
      _id: req.params.id,
      userId: req.user.id,
    });

    if (!task) {
      return res.status(404).json({
        success: false,
        message: "Task not found",
      });
    }

    task.completed = !task.completed;
    task.completedAt = task.completed ? new Date() : null;

    await task.save();

    res.status(200).json({
      success: true,
      message: `Task ${task.completed ? "completed" : "uncompleted"}`,
      task,
    });
  } catch (error) {
    next(error);
  }
};

